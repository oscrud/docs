[{"title":"Another Golang Framework - Oscrud","type":0,"sectionRef":"#","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud","content":"","keywords":""},{"title":"Table Of Contents","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud#table-of-contents","content":"TransportServiceLoggerBinderOptions "},{"title":"Transport","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud#transport","content":"Transport part in oscrud is about the way for framework receiving request and response to request like http and websockets. Currently only support Echo which done by myself. Transport is an interface, its have only three method that must implement. Name() to declare transport name to whether know the request come from which transport. Register() will called everytime register endpoint have been called at core struct. Start() will just been called once when core struct have fired start. Copy type Transport struct{} func(t *Transport)Name()string{ return\"TransportName\" } func(t *Transport)Register(method string, endpoint string, handler oscrud.TransportHandler){ // Every endpoint registration will call this method. } func(t *Transport)Start()error{ // Transport start receiving request } "},{"title":"Service","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud#service","content":"Service part in oscrud is expect to be support ORM and expose CRUD endpoints with a single model definition. Service by default come with 6 actions following CRUD standard. Currently customizing a service may required some basic knowledge on reflect package, but we trying to minimize usage of reflect when creating own services and we also only supported one of the ORM only for now Sqlike. Here the list of endpoint will be registered. Copy GET /basePath - Service.Find POST /basePath - Service.Create GET /basePath/:$id - Service.Get PUT /basePath/:$id - Service.Update PATCH /basePath/:$id - Service.Patch DELETE /basePath/:$id - Service.Delete For creating own service, must implement the interface have been defined in oscrud. And there also come with 2 built in Query objects, oscrud.Query and oscrud.QueryOne for bind data from requests and standardize query naming for all services. Example of built-in query for oscrud.QueryOne is just $select for ORM to know selecting which field only. And oscrud.Query have $select, $order to defined ascending or descending, and some pagination keyword ( $cursor, $offset, $page, $limit ). Copy type Service struct{} func(service Service)Create(ctx oscrud.Context) oscrud.Context { // Createing data } func(service Service)Find(ctx oscrud.Context) oscrud.Context { // List data } func(service Service)Get(ctx oscrud.Context) oscrud.Context { // Get data ( should be one result always ) } func(service Service)Update(ctx oscrud.Context) oscrud.Context { // update data } func(service Service)Patch(ctx oscrud.Context) oscrud.Context { // patch data } func(service Service)Delete(ctx oscrud.Context) oscrud.Context { // delete data } For work with the service, need a service model. Service Model is a struct usually will be a table in database. So when work with service, we can use method to filter result or returning data even prevent toxic data injection. $id tag will automatically assign input value from endpoint, such as GET /test/:$id for a Get action. Copy // User : type User struct{ Key *types.Key `json:\"-\"` ID string`json:\"id\" qm:\"$id\" sqlike:\"-\"` Name string`json:\"name\"` } // ToCreate : func(user *User)ToCreate()(interface{},error){ user.Key = types.NewIDKey(\"User\",nil) user.Name +=\"-\"+ util.RandomString(6) iflen(user.Name)>20{ returnnil, errors.New(\"username have a maximum length 20\") } return user,nil } // ToResult : func(user *User)ToResult()(interface{},error){ if user.Key !=nil{ user.ID = user.Key.ID() } return user,nil } // ToQuery : func(user *User)ToQuery()(interface{},error){ if user.ID !=\"\"{ return expr.Equal(\"Key\",\"User,\"+user.ID),nil } var query interface{} if user.Name !=\"\"{ query = expr.Equal(\"Name\", user.Name) } return query,nil } // ToPatch : func(user *User)ToPatch(incoming oscrud.ServiceModel)(interface{},error){ incomingUser := incoming.(*User) user.Name = incomingUser.Name return user,nil } // ToUpdate : func(user *User)ToUpdate(incoming oscrud.ServiceModel)(interface{},error){ incomingUser := incoming.(*User) user.Name = incomingUser.Name return user,nil } // ToDelete : func(user *User)ToDelete()(interface{},error){ return user,nil } "},{"title":"Logger","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud#logger","content":"Logger is an important part for every library, framework to track down any issues or bug in the code. So logger will be track down when incoming request & outgoing response, also when doing API user can also log down the operation, content with the core struct. All of the logger method will run in goroutine to prevent slowing down when processing request. Copy // Logger : type Logger struct{} // Log : func(l Logger)Log(operation string, content string){ log.Println(\"Operation - \", operation) log.Println(\"Content - \", content) } // StartRequest : func(l Logger)StartRequest(ctx oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } // EndRequest : func(l Logger)EndRequest(ctx oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } funcmain(){ server := oscrud.NewOscrud() server.RegisterLogger(Logger{}) server.Log(\"Action\",\"Content\") } "},{"title":"Binder","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud#binder","content":"Binder is a serialize & deserialize library to easily customize serialize / deserialize from Type A to Type B. Binder will be default binder for oscrud framework but you can make your own binder also ( but not recommended ). Every type have default binding method included primitive types, slice, array and struct. By default, primitive types will convert to string and reflect.Set() to field. For slice, struct, array will be check assignableTo only reflect.Set() to field. You can still customize all of the binder method, registered method will have higher priority than default method. This binder is another package under Oscrud also so you can use it standalone without the framework. Oscrud Binder With Default Method ( for primitive types only ) Copy package main import( \"log\" \"github.com/oscrud/oscrud-binder\" ) funcmain(){ binder := binder.NewBinder() var data int32 if err := binder.Bind(&data,\"30\"); err !=nil{ log.Println(err) } log.Println(data)// 30 if err := binder.Bind(&data,int64(10)); err !=nil{ log.Println(err) } log.Println(data)// 10 if err := binder.Bind(&data,\"20.5\"); err !=nil{ log.Println(err)// trying to convert 20.5 to int32 } } With Custom Method ( Registered to Binder before use ) Copy package main import( \"log\" \"fmt\" \"github.com/oscrud/oscrud-binder\" ) type AnyStruct struct{ Data string } funcmain(){ binder := binder.NewBinder() // register from string to AnyStruct binder.Register(string(\"\"), AnyStruct{},func(raw interface{})(interface{},error){ return AnyStruct{fmt.Sprintf(raw)} }) // register from AnyStruct to string // without this will will parse automatically with fmt.Sprintf(\"%v\", raw) binder.Register(AnyStruct{},string(\"\"),func(raw interface{})(interface{},error){ strct := raw.(AnyStruct) return strct.Data }) strct :=new(AnyStruct) if err := binder.Bind(&strct,\"will set to data\"); err !=nil{ log.Println(err) } log.Println(strct.Data)// will set to data var str string if err := binder.Bind(&str, strct); err !=nil{ log.Println(err) } log.Println(str)// will set to data if err := binder.Bind(&strct,10); err !=nil{ log.Println(err)// Trying to convert 10 to struct AnyStruct } } "},{"title":"Options","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/07/28/20200608-another-golang-framework-oscrud#options","content":"Options will be like middleware at other framework. Currently only supported TimeoutOptions, EventOptions and MiddlewareOption. It can be under server level or endpoint level. Copy package oscrud server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx oscrud.Context) oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } event := oscrud.EventOptions{ OnComplete:func(ctx oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, } // You can just apply all in one line. server.UseOptions(middleware, event) // Also work with endpoint only server.RegisterEndpoint(\"GET\",\"/test\",func(ctx oscrud.Context) oscrud.Context { return ctx.String(200,\"Hello World\").End() }, middleware, event) Lastly, this framework is still under development so not suggested to use in production. There also come with an example about all current features and documentation is under main repository will be expose soon with the github templates. Any suggestions would be greatly appreciated. "},{"title":"All Binding","type":0,"sectionRef":"#","url":"docs/binder/all-binding","content":"All binding will bind all possible valus by get key from reflect.Tag and retrieve value from all maps, if exists will bind to struct. qm tag have higher priority then json so if qm tag exists, will take qm instead of json. After having the tag value will try to get value from header, query, body, param and request-level state. Binding struct when calling must have addressable, if not will return error ErrSourceNotAddressable. Copy var i struct{ Id string`qm:\"id\"` Token string`json:\"token\" qm:\"x-authorization\"` } ctx.BindAll(&i)","keywords":""},{"title":"Oscrud Binder","type":0,"sectionRef":"#","url":"docs/binder/overview","content":"Binder is for data binding when transform incoming requests data to a specified struct / type / array or slice. Currently customization only supported on struct, slice and array, primitive type will set by reflect.Set().","keywords":""},{"title":"Registering New Binder","type":0,"sectionRef":"#","url":"docs/binder/register-new-binder","content":"Registering new binder for sepcific type ( struct, array or slice ), primitive not supported yet. Copy type Example struct{ Line1 string Line2 string } funcmain(){ // You use binder independently also binder := oscrud.NewBinder() binder.Register(new(Example),func(raw interface{})(interface{},error){ str := fmt.Sprintf(\"%v\", raw) if strings.Contains(raw,\",\"){ split := strings.Split(raw,\",\") return Example{raw[0], raw[1]},nil } returnnil, fmt.Errorf(\"Invalid data \"%v\" for deserialize to Example\", raw) }) example :=new(Example) err := binder.Bind(&example,\"line1,line2\") log.Println(example, err)// { line1, line2 }, <nil> err := binder.Bind(&example,\"line1-line2\") log.Println(example, err)// nil, \"Invalid data line-line2 for deserialize to Example\" }","keywords":""},{"title":"Specific Binding","type":0,"sectionRef":"#","url":"docs/binder/specific-binding","content":"Specific binding will bind value based on specified tag. If you want to bind from all with specified key, you can use all binding instead of specific binding. Binding struct when calling must have addressable, if not will return error ErrSourceNotAddressable. header will target to Header. query will target to Query. body will target to Body. param will target to Param.state will target to Request Level State Copy var i struct{ Token string`header:\"token\"` IsNew string`query:\"isNew\"` Username string`body:\"username\"` Password string`body:\"password\"` Id string`param:\"id\"` State string`state:\"state\"` } ctx.Bind(&i)","keywords":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/getting-start","content":"If you doesn't have Go installed on your pc. You can get it here. Copy $ go get -u github.com/oscrud/oscrud After complete installation, you can Go with your beloved framework and here an hello world example. You can choose your own transport from lists, currently only supported Echo. For future will implement service discovery by default. Copy package oscrud import( \"github.com/oscrud/oscrud\" ) funcmain(){ server := oscrud.NewOscrud() server.RegisterTransport(e.NewEcho(echo.New()).UsePort(3000)) server.RegisterEndpoint(\"GET\",\"/test\",func(ctx oscrud.Context) oscrud.Context { return ctx.String(200,\"Hello World\").End() }) server.Start() } $ curl -v localhost:3000/test > GET /test HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.58.0 > Accept:*/* > < HTTP/1.1 200 OK < Content-Type: text/plain; charset=UTF-8 < Date: Fri, 31 Jan 2020 16:04:49 GMT < Content-Length: 11 < * Connection #0 to host localhost left intact Hello World","keywords":""},{"title":"Example Handler","type":0,"sectionRef":"#","url":"docs/handler/example","content":"For endpoint, must have a handler that calling End() method, if not will throwing error due to context haven't end yet. Why with this design, because of we make handler can be invoke until After middleware options and can be apply for profiler, logger about context. Copy funcExample(ctx oscrud.Context) oscrud.Context { return ctx.String(200,\"Example Handler\").End() } funcmain(){ server := oscrud.NewOscrud() server.RegisterEndpoint(\"GET\",\"/example\", Example) }","keywords":""},{"title":"Oscrud Handler","type":0,"sectionRef":"#","url":"docs/handler/overview","content":"oscrud.Handler is just a function func(Context) Context. oscrud.Handler act as main handler for whole framework, endpoint handler is using it and middleware options also using the same handler.","keywords":""},{"title":"Request Context","type":0,"sectionRef":"#","url":"docs/handler/request","content":"Method\tDescriptionMethod() string\tReturn request method, default to be smaller case get, post. Get(key string) interface{}\tGet value by key from param, query, body, header, order respectively. Context() context.Context\tGet request context Transport() TransportID\tGet transport name Path() string\tReturn request path RequestID() string\tReturn request id State() map[string]interface{}\tReturn request state Headers() map[string]string\tReturn request headers Query() map[string]interface{}\tReturn request queries Params() map[string]string\tReturn request params Body() map[string]interface{}\tReturn request body Bind(src interface{}) error\tBind data from map specify by reflect.Tag. More information please look at Specific Binding. BindAll(src interface{}) error\tBind data from param, query, body, header, state based on json and qm tag. More information please look at All Binding. SetState(key string, value interface{})\tSet data to request level state","keywords":""},{"title":"Response Context","type":0,"sectionRef":"#","url":"docs/handler/response-object","content":"Method\tDescriptionContentType() string\tReturn response content type ResponseHeaders() map[string]string\tReturn response headers Status() int\tReturn response status Exception() error\tReturn response error Result() interface{}\tReturn response result ErrorMap() map[string]interface{}\tReturn pretty error","keywords":""},{"title":"Response Context","type":0,"sectionRef":"#","url":"docs/handler/response","content":"Method\tDescriptionSet(key string, value string) Context\tAppend header to response, will override if key exists NoContent() Context\tResponse with status 204, and empty result. NotFound() Context\tResponse with status 404, and not found error. String(status int, text string) Context\tResponse with status, and raw string. Content type will be set as text/plain HTML(status int, html string) Context\tResponse with status, and html string. Content type will be set as text/html. JSON(status int, i interface{}) Context\tResponse with status, and interface. Content type will be set as application/json. XML(status int, i interface{}) Context\tResponse with status, and interface. Content type will be set as application/xml. Send(status int, contentType string, i interface{}) Context\tResponse with status, content type and interface. Transport should be handle on this if not will return error ErrResponseFailed. Error(status int, exception error)\tResponse with status, and given error Stack(status int, exception error)\tResponse with status, and given error ( stack will be provided ). errors.WithStack(). End() Context\tA signal to tell handler, the flow is reach end already. If End() didn't call until end of the handler, will return error ErrResponseNotComplete. Response() Response\tReturn response object","keywords":""},{"title":"Event Options","type":0,"sectionRef":"#","url":"docs/options/event","content":"Event options is for applying event-driven functionality, like OnComplete. For some of the transport may have bidirectional communicate, so have to remind when every requests complete. And this function will invoke using go-routine. As order will run endpoint options and only we run server options. Copy event := oscrud.EventOptions{ OnComplete:func(ctx oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, }","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/introduction","content":"","keywords":""},{"title":"PR & Suggestion","type":1,"pageTitle":"Introduction","url":"docs/introduction#pr--suggestion","content":"CasesExampleSolving Issues "},{"title":"Issues","type":1,"pageTitle":"Introduction","url":"docs/introduction#issues","content":"Simple exampleWay to reproduce issuesIssues about Version "},{"title":"Middleware Options","type":0,"sectionRef":"#","url":"docs/options/middleware","content":"Middleware options is for applying before and after lifecycle to endpoint or server. So if both server and endpoint middleware specified, will run based on : Incoming Request --> server.Before -> endpoint.Before -> Main handler -> endpoint.After -> server.After -> Outgoing Response. Copy // MiddlewareOptions : type MiddlewareOptions struct{ Before []Handler After []Handler }","keywords":""},{"title":"Transport Options","type":0,"sectionRef":"#","url":"docs/options/transport","content":"Transport Options is to limiting endpoint registration for some specified transport. Disabled transport will not receiving that route registeration. Copy disable := oscrud.TransportOptions{ DisableRegister:map[oscrud.TransportID]bool{ echo.TransportID:true, }, }","keywords":""},{"title":"example","type":0,"sectionRef":"#","url":"docs/package/example","content":"","keywords":""},{"title":"Timeout Options","type":0,"sectionRef":"#","url":"docs/options/timeout","content":"Timeout options is apply timeout for endpoint or server. Priority will take endpoint timeout options, if not specified will take server's timeout options. If none of them specified, will have a default 30 seconds timeout for every request. Copy timeout := oscrud.TimeoutOptions{ Duration:1* time.Microsecond, OnTimeout:func(ctx oscrud.Context) oscrud.Context { return ctx.Error(408, errors.New(\"Another requestimeout\")).End() }, }","keywords":""},{"title":"graphql-handler","type":0,"sectionRef":"#","url":"docs/package/graphql-handler","content":"","keywords":""},{"title":"Request Lifecycle","type":0,"sectionRef":"#","url":"docs/reference/content-type","content":"List of oscrud original content-type. you can pass custom content type also but you will need to handle at transport layer so will depend on transport. Copy // ContentType Definition var( ContentTypePlainText =\"text/plain\" ContentTypeHTML =\"text/html\" ContentTypeJSON =\"application/json\" ContentTypeXML =\"application/xml\" )","keywords":""},{"title":"Errors List","type":0,"sectionRef":"#","url":"docs/reference/error-list","content":"Error\tDescription\tMessageErrNotFound\tdefault endpoint not found error message & ctx.NotFound() error message\tendpoint or service not found ErrResponseNotComplete\terror message when End() doesn't called and reach end of handler.\tresponse doesn't called end in all handlers ErrResponseFailed\terror message when Send()'s information, transport unable to handler or not supported\tresponse doesn't return properly in transport ErrSourceNotAddressable\terror message when binding source is not addressable\tbinder source must be addressable ErrRequestTimeout\tdefault request timeout error message\trequest timeout","keywords":""},{"title":"Request Lifecycle","type":0,"sectionRef":"#","url":"docs/reference/request-lifecycle","content":"Basically a request firstly will come to Transport. Transport will do the basic handling to construct a oscrud.Request and only bring request to oscrud. Transport Usually process incoming request and construct request for pass to handler. Start Request Logger Timeout Handler Construct timeout handler & run handler using go-routine. When timeout reach will just return timeout error. Oscrud Lookup route, if exists construct middleware handler & main handler which required for the route. Before Middleware HandlerMain HandlerAfter Middleware HandlerEvent onComplete()End Request Logger","keywords":""},{"title":"Get Transport","type":0,"sectionRef":"#","url":"docs/server/get-transport","content":"Get transport by id from transport list Copy package oscrud funcmain(){ server := oscrud.NewOscrud() echo, exists := server.GetTransport(echo.TransportID) }","keywords":""},{"title":"Manually Log","type":0,"sectionRef":"#","url":"docs/server/manual-log","content":"Logging some operation with content, server context will run through loggers and call log function. Copy package oscrud funcmain(){ oscrud.Log(\"Request\",\"request started\") }","keywords":""},{"title":"Constructing Oscrud","type":0,"sectionRef":"#","url":"docs/server/new-oscrud","content":"For constructing a new instance with some default parameters. Preferred to use this instead construct yourself unless you know what you're doing. Copy package oscrud funcmain(){ server := oscrud.NewOscrud() }","keywords":""},{"title":"Constructing Request","type":0,"sectionRef":"#","url":"docs/server/new-request","content":"Constructing new request for access endpoint. Mainly for transport. Copy req := oscrud.NewRequest(). Transport(t). Context(e). SetBody(body). SetQuery(query). SetHeader(header). SetParam(param)","keywords":""},{"title":"Oscrud Server","type":0,"sectionRef":"#","url":"docs/server/overview","content":"oscrud.Server is the core struct of the framework, inside server core you can have setup method to initialize components ( middleware, binder, and more ).","keywords":""},{"title":"Registering Binder","type":0,"sectionRef":"#","url":"docs/server/register-binder","content":"For register data binding method for specific struct / array / slice. Incoming data can be any type so suggested to be make a switch-case statement with default by handling other type that not supported ( usually just a string from 'header', 'query', 'body' or 'param' ). Copy package main import( \"log\" \"fmt\" \"github.com/oscrud/oscrud\" ) type AnyStruct struct{ Data string } funcmain(){ server := oscrud.NewOscrud() // register from string to AnyStruct server.RegisterBinder(string(\"\"), AnyStruct{},func(raw interface{})(interface{},error){ return AnyStruct{fmt.Sprintf(raw)} }) // register from AnyStruct to string // without this will will parse automatically with fmt.Sprintf(\"%v\", raw) server.RegisterBinder(AnyStruct{},string(\"\"),func(raw interface{})(interface{},error){ strct := raw.(AnyStruct) return strct.Data }) }","keywords":""},{"title":"Registering Endpoints","type":0,"sectionRef":"#","url":"docs/server/register-endpoint","content":"For registering endpoint with specified method, endpoint & handler, and also able to apply endpoint level options ( mean only work on the specifed endpoint ). Copy package oscrud funcmain(){ server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx oscrud.Context) oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } event := oscrud.EventOptions{ OnComplete:func(ctx oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, } // options can be apply in one line also. server.RegisterEndpoint(\"GET\",\"/test\",func(ctx oscrud.Context) oscrud.Context { return ctx.String(200,\"Hello World\").End() }, event, middleware) }","keywords":""},{"title":"Registering Services","type":0,"sectionRef":"#","url":"docs/server/register-service","content":"For registering service on a specified path, basically service would includes 6 endpoints. It's have same registering strategy with endpoint. GET /basePath - Service.FindGET /basePath/:$id - Service.GetPOST /basePath - Service.CreatePUT /basePath/:$id - Service.UpdatePATCH /basePath/:$id - Service.PatchDELETE /basePath/:$id - Service.Delete Copy package oscrud funcmain(){ server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx oscrud.Context) oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } // Sqlike database conn initialize client := sql.MustConnect(\"mysql\", options.Connect(). SetHost(\"localhost\"). SetPort(\"3306\"). SetUsername(\"root\"). SetPassword(\"test\"), ) client.SetPrimaryKey(\"Key\") // Service Definition service := sqlike.NewService(client).Database(\"test\") // User is a query model struct based on oscrud.DataModel interface server.RegisterService(\"test\", service.ToService(\"user\",new(User)), middleware) }","keywords":""},{"title":"Registering Loggers","type":0,"sectionRef":"#","url":"docs/server/register-logger","content":"For register logger for the server. Every request made will be run all logger in goroutine, prevent for slowing down requests. Copy package oscrud // Logger : type Logger struct{ } // Log : func(l Logger)Log(operation string, content string){ log.Println(\"Operation - \", operation) log.Println(\"Content - \", content) } // StartRequest : func(l Logger)StartRequest(ctx oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } // EndRequest : func(l Logger)EndRequest(ctx oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } funcmain(){ server := oscrud.NewOscrud() server.RegisterLogger(Logger{}) }","keywords":""},{"title":"Registering Trasnports","type":0,"sectionRef":"#","url":"docs/server/register-transport","content":"For register transport for the server, must be called before any endpoint registration. Every transport must be implemented based on interface. Copy package oscrud funcmain(){ server := oscrud.NewOscrud() server.RegisterTransport(e.NewEcho(echo.New()).UsePort(3000)) }","keywords":""},{"title":"Start Server","type":0,"sectionRef":"#","url":"docs/server/start","content":"For start the oscrud server, server starting will only start all the registered transport. No transported registered will panic with err. No any setup will be invoke at this step, all would be done when register, so internal call / access can be work before or even not calling Start(). Copy funcmain(){ server := oscrud.NewOscrud() server.Start() }","keywords":""},{"title":"Server State","type":0,"sectionRef":"#","url":"docs/server/state","content":"Get & Set application level state, you will have it when u have the server instance. Copy package oscrud funcmain(){ oscrud.SetState(\"state\",\"some_str\") state := oscrud.GetState(\"state\") log.Println(state)// some_str }","keywords":""},{"title":"Creating Own Oscrud Service","type":0,"sectionRef":"#","url":"docs/service/create-own-service","content":"For creating own service, you must have implement methods based on oscrud.Service interface. There built in have 2 Query Struct ( oscrud.Query, oscrud.QueryOne ) for bind data from incoming requests, mainly for standardize query naming. Copy type Service struct{} func(service Service)Create(ctx oscrud.Context) oscrud.Context { // Createing data } func(service Service)Find(ctx oscrud.Context) oscrud.Context { // List data } func(service Service)Get(ctx oscrud.Context) oscrud.Context { // Get data ( should be one result always ) } func(service Service)Update(ctx oscrud.Context) oscrud.Context { // update data } func(service Service)Patch(ctx oscrud.Context) oscrud.Context { // patch data } func(service Service)Delete(ctx oscrud.Context) oscrud.Context { // delete data }","keywords":""},{"title":"Using Options","type":0,"sectionRef":"#","url":"docs/server/use-options","content":"For apply server-level options ( mean apply to all endpoints ). Copy package oscrud funcmain(){ server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx oscrud.Context) oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } event := oscrud.EventOptions{ OnComplete:func(ctx oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, } // You can just apply all in one line. server.UseOptions(middleware, event) }","keywords":""},{"title":"Default Query for Find","type":0,"sectionRef":"#","url":"docs/service/find-query","content":"$select as selecting which field to return from server-side. Example ?$select=Name,Key will returning Name & Key only. $order as order based on desc or asc. $cursor as cursor for pagination based on Service, they will filter by cursor or offset. $offset as offset for pagination based on Service, they will filter by cursor or offset. $page as page for pagination based on Service, they will filter by cursor or offset. $limit as limit for pagination based on Service, they will filter by cursor or offset. Copy package oscrud // Query : type Query struct{ Cursor string`query:\"$cursor\"` Offset int`query:\"$offset\"` Page int`query:\"$page\"` Limit int`query:\"$limit\"` Order string`query:\"$order\"` Select string`query:\"$select\"` }","keywords":""},{"title":"Defining Data Model","type":0,"sectionRef":"#","url":"docs/service/data-model","content":"Service model is a model struct usually will be a table from database. Service model must have implmenet method from oscrud.DataModel. So when creating own service, we can use method to filter result or returning data even prevent toxic data injection. $id tag will automatically assign input value from endpoint, such as GET /test/:$id for a Get action. Method\tUsageToQuery() (interface{}, error)\tFor returning query syntax based on service requirement, for sqlike is expr cosntruct from their query builder. ToUpdate(ServiceModel) (interface{}, error)\tFor construct model and return for update ToPatch(ServiceModel) (interface{}, error)\tFor construct model and return for patch ToCreate() (interface{}, error)\tFor construct model and return for create ToResult() (interface{}, error)\tFor construct model and return for find / get Copy // User : type User struct{ Key *types.Key `json:\"-\"` ID string`json:\"id\" qm:\"$id\" sqlike:\"-\"` Name string`json:\"name\"` } // ToCreate : func(user *User)ToCreate()(interface{},error){ user.Key = types.NewIDKey(\"User\",nil) user.Name +=\"-\"+ util.RandomString(6) iflen(user.Name)>20{ returnnil, errors.New(\"username have a maximum length 20\") } return user,nil } // ToResult : func(user *User)ToResult()(interface{},error){ if user.Key !=nil{ user.ID = user.Key.ID() } return user,nil } // ToQuery : func(user *User)ToQuery()(interface{},error){ if user.ID !=\"\"{ return expr.Equal(\"Key\",\"User,\"+user.ID),nil } var query interface{} if user.Name !=\"\"{ query = expr.Equal(\"Name\", user.Name) } return query,nil } // ToPatch : func(user *User)ToPatch(incoming oscrud.ServiceModel)(interface{},error){ incomingUser := incoming.(*User) user.Name = incomingUser.Name return user,nil } // ToUpdate : func(user *User)ToUpdate(incoming oscrud.ServiceModel)(interface{},error){ incomingUser := incoming.(*User) user.Name = incomingUser.Name return user,nil } // ToDelete : func(user *User)ToDelete()(interface{},error){ return user,nil }","keywords":""},{"title":"Default Query for Get","type":0,"sectionRef":"#","url":"docs/service/get-query","content":"$select as selecting which field to return from server-side. Example ?$select=Name,Key will returning Name & Key only. Copy package oscrud // QueryOne : type QueryOne struct{ Select string`query:\"$select\"` }","keywords":""},{"title":"Oscrud Service","type":0,"sectionRef":"#","url":"docs/service/ovrview","content":"Service has 6 action following CRUD standard. Basically service will registering 6 endpoints by default. Currently creating a service may required some basic knowledge on reflect package, we trying to minimize usage of reflect when creating own service. GET /basePath - Service.FindPOST /basePath - Service.CreateGET /basePath/:$id - Service.GetPUT /basePath/:$id - Service.UpdatePATCH /basePath/:$id - Service.PatchDELETE /basePath/:$id - Service.Delete","keywords":""},{"title":"Oscrud Transport","type":0,"sectionRef":"#","url":"docs/transport/overview","content":"Transport act as communicate tools between client and server. Transport would have own name to determine request is from which transport.","keywords":""},{"title":"Creating Own Oscrud Transport","type":0,"sectionRef":"#","url":"docs/transport/create-own-transport","content":"For creating own transport, you have to implement method from oscrud.Transport. Basically have 2 type registraion way. Way 1 is in Register for those transport which support endpoint routing like Echo. Way 2 is in Start for those transport doesn't have a router support like net/http package. Copy type Transport struct{} const( TransportName oscrud.TransportID =\"TransportName\" ) func(t *Transport)Name() oscrud.TransportID { return TransportName } func(t *Transport)Register(method string, endpoint string, handler oscrud.TransportHandler){ // Every endpoint registration will call this method. } func(t *Transport)Start()error{ // Transport start receiving request }","keywords":""}]