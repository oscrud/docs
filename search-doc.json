[{"title":"Another Golang Framework - Oscrud","type":0,"sectionRef":"#","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud","content":"","keywords":""},{"title":"Table Of Contents","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud#table-of-contents","content":"Table Of ContentsTransportServiceLoggerBinderOptions "},{"title":"Transport","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud#transport","content":"Transport part in oscrud is about the way for framework receiving request and response to request like http and websockets. Currently only support Echo which done by myself. Transport is an interface, its have only three method that must implement. Name() to declare transport name to whether know the request come from which transport. Register() will called everytime register endpoint have been called at core struct. Start() will just been called once when core struct have fired start. Copy type Transport struct{} func(t *Transport)Name()string{ return\"TransportName\" } func(t *Transport)Register(method string, endpoint string, handler oscrud.TransportHandler){ // Every endpoint registration will call this method. } func(t *Transport)Start()error{ // Transport start receiving request } "},{"title":"Service","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud#service","content":"Service part in oscrud is expect to be support ORM and expose CRUD endpoints with a single model definition. Service by default come with 6 actions following CRUD standard. Currently customizing a service may required some basic knowledge on reflect package, but we trying to minimize usage of reflect when creating own services and we also only supported one of the ORM only for now Sqlike. Here the list of endpoint will be registered. Copy GET /basePath - Service.Find POST /basePath - Service.Create GET /basePath/:$id - Service.Get PUT /basePath/:$id - Service.Update PATCH /basePath/:$id - Service.Patch DELETE /basePath/:$id - Service.Delete For creating own service, must implement the interface have been defined in oscrud. And there also come with 2 built in Query objects, oscrud.Query and oscrud.QueryOne for bind data from requests and standardize query naming for all services. Example of built-in query for oscrud.QueryOne is just $select for ORM to know selecting which field only. And oscrud.Query have $select, $order to defined ascending or descending, and some pagination keyword ( $cursor, $offset, $page, $limit ). Copy type Service struct{} func(service Service)Create(ctx *oscrud.Context)*oscrud.Context { // Createing data } func(service Service)Find(ctx *oscrud.Context)*oscrud.Context { // List data } func(service Service)Get(ctx *oscrud.Context)*oscrud.Context { // Get data ( should be one result always ) } func(service Service)Update(ctx *oscrud.Context)*oscrud.Context { // update data } func(service Service)Patch(ctx *oscrud.Context)*oscrud.Context { // patch data } func(service Service)Delete(ctx *oscrud.Context)*oscrud.Context { // delete data } For work with the service, need a service model. Service Model is a struct usually will be a table in database. So when work with service, we can use method to filter result or returning data even prevent toxic data injection. $id tag will automatically assign input value from endpoint, such as GET /test/:$id for a Get action. Copy // User : type User struct{ Key *types.Key `json:\"-\"` ID string`json:\"id\" qm:\"$id\" sqlike:\"-\"` Name string`json:\"name\"` } // ToCreate : func(user *User)ToCreate()(interface{},error){ user.Key = types.NewIDKey(\"User\",nil) user.Name +=\"-\"+ util.RandomString(6) iflen(user.Name)>20{ returnnil, errors.New(\"username have a maximum length 20\") } return user,nil } // ToResult : func(user *User)ToResult()(interface{},error){ if user.Key !=nil{ user.ID = user.Key.ID() } return user,nil } // ToQuery : func(user *User)ToQuery()(interface{},error){ if user.ID !=\"\"{ return expr.Equal(\"Key\",\"User,\"+user.ID),nil } var query interface{} if user.Name !=\"\"{ query = expr.Equal(\"Name\", user.Name) } return query,nil } // ToPatch : func(user *User)ToPatch(incoming oscrud.ServiceModel)(interface{},error){ incomingUser := incoming.(*User) user.Name = incomingUser.Name return user,nil } // ToUpdate : func(user *User)ToUpdate(incoming oscrud.ServiceModel)(interface{},error){ incomingUser := incoming.(*User) user.Name = incomingUser.Name return user,nil } // ToDelete : func(user *User)ToDelete()(interface{},error){ return user,nil } "},{"title":"Logger","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud#logger","content":"Logger is an important part for every library, framework to track down any issues or bug in the code. So logger will be track down when incoming request & outgoing response, also when doing API user can also log down the operation, content with the core struct. All of the logger method will run in goroutine to prevent slowing down when processing request. Copy // Logger : type Logger struct{} // Log : func(l Logger)Log(operation string, content string){ log.Println(\"Operation - \", operation) log.Println(\"Content - \", content) } // StartRequest : func(l Logger)StartRequest(ctx *oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } // EndRequest : func(l Logger)EndRequest(ctx *oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } funcmain(){ server := oscrud.NewOscrud() server.RegisterLogger(Logger{}) server.Log(\"Action\",\"Content\") } "},{"title":"Binder","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud#binder","content":"Binder is a serialize & deserialize library to easily customize serialize / deserialize from Type A to Type B. Binder will be default binder for oscrud framework but you can make your own binder also ( but not recommended ). Every type have default binding method included primitive types, slice, array and struct. By default, primitive types will convert to string and reflect.Set() to field. For slice, struct, array will be check assignableTo only reflect.Set() to field. You can still customize all of the binder method, registered method will have higher priority than default method. This binder is another package under Oscrud also so you can use it standalone without the framework. Oscrud Binder With Default Method ( for primitive types only ) Copy package main import( \"log\" \"github.com/oscrud/oscrud-binder\" ) funcmain(){ binder := binder.NewBinder() var data int32 if err := binder.Bind(&data,\"30\"); err !=nil{ log.Println(err) } log.Println(data)// 30 if err := binder.Bind(&data,int64(10)); err !=nil{ log.Println(err) } log.Println(data)// 10 if err := binder.Bind(&data,\"20.5\"); err !=nil{ log.Println(err)// trying to convert 20.5 to int32 } } With Custom Method ( Registered to Binder before use ) Copy package main import( \"log\" \"fmt\" \"github.com/oscrud/oscrud-binder\" ) type AnyStruct struct{ Data string } funcmain(){ binder := binder.NewBinder() // register from string to AnyStruct binder.Register(string(\"\"), AnyStruct{},func(raw interface{})(interface{},error){ return AnyStruct{fmt.Sprintf(raw)} }) // register from AnyStruct to string // without this will will parse automatically with fmt.Sprintf(\"%v\", raw) binder.Register(AnyStruct{},string(\"\"),func(raw interface{})(interface{},error){ strct := raw.(AnyStruct) return strct.Data }) strct :=new(AnyStruct) if err := binder.Bind(&strct,\"will set to data\"); err !=nil{ log.Println(err) } log.Println(strct.Data)// will set to data var str string if err := binder.Bind(&str, strct); err !=nil{ log.Println(err) } log.Println(str)// will set to data if err := binder.Bind(&strct,10); err !=nil{ log.Println(err)// Trying to convert 10 to struct AnyStruct } } "},{"title":"Options","type":1,"pageTitle":"Another Golang Framework - Oscrud","url":"blog/2020/09/23/20200608-another-golang-framework-oscrud#options","content":"Options will be like middleware at other framework. Currently only supported TimeoutOptions, EventOptions and MiddlewareOption. It can be under server level or endpoint level. Copy package oscrud server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx *oscrud.Context)*oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } event := oscrud.EventOptions{ OnComplete:func(ctx *oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, } // You can just apply all in one line. server.UseOptions(middleware, event) // Also work with endpoint only server.RegisterEndpoint(\"GET\",\"/test\",func(ctx *oscrud.Context)*oscrud.Context { return ctx.String(200,\"Hello World\").End() }, middleware, event) Lastly, this framework is still under development so not suggested to use in production. There also come with an example about all current features and documentation is under main repository will be expose soon with the github templates. Any suggestions would be greatly appreciated. "},{"title":"All Binding","type":0,"sectionRef":"#","url":"docs/binder/all-binding","content":"All binding will bind all possible valus by get key from reflect.Tag and retrieve value from all maps, if exists will bind to struct. oscrud tag have higher priority then json so if oscrud tag exists, will take oscrud instead of json. After having the tag value will try to get value from header, query, body, param, form and request-level state. Binding struct when calling must have addressable, if not will return error ErrSourceNotAddressable. You can pass extra setting for bind using golang built-in ways, etc json package. Copy var i struct{ Id string`oscrud:\"id\"` Token string`json:\"token\" oscrud:\"x-authorization\"` } ctx.BindAll(&i) // bind with json package ctx.BindAll(&i, oscrud.BinderSetting{UseJSON:true})","keywords":"documentation oscrud binder"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/binder/overview","content":"","keywords":"documentation oscrud binder"},{"title":"Example","type":1,"pageTitle":"Overview","url":"docs/binder/overview#example","content":"Copy package main import( \"log\" \"github.com/oscrud/oscrud-binder\" ) funcmain(){ binder := binder.NewBinder() var data int32 if err := binder.Bind(&data,\"30\"); err !=nil{ log.Println(err) } log.Println(data)// 30 if err := binder.Bind(&data,int64(10)); err !=nil{ log.Println(err) } log.Println(data)// 10 if err := binder.Bind(&data,\"20.5\"); err !=nil{ log.Println(err)// trying to convert 20.5 to int32 } } "},{"title":"Specific Binding","type":0,"sectionRef":"#","url":"docs/binder/specific-binding","content":"Specific binding will bind value based on specified tag. If you want to bind from all with specified key, you can use all binding instead of specific binding. Binding struct when calling must have addressable, if not will return error ErrSourceNotAddressable. header will target to Header. query will target to Query. body will target to Body. param will target to Param.form will target to Form.state will target to Request Level State Copy var i struct{ Token string`header:\"token\"` IsNew string`query:\"isNew\"` Username string`body:\"username\"` Password string`body:\"password\"` Id string`param:\"id\"` State string`state:\"state\"` FormData string`form:\"data\"` } ctx.Bind(&i)","keywords":"documentation oscrud binder"},{"title":"Register Binder","type":0,"sectionRef":"#","url":"docs/binder/register-new-binder","content":"Registering new binder for sepcific type ( struct, array or slice ), primitive not supported yet. Copy package main import( \"log\" \"fmt\" \"github.com/oscrud/oscrud-binder\" ) type AnyStruct struct{ Data string } funcmain(){ binder := binder.NewBinder() binder.Register(string(\"\"), AnyStruct{},func(raw interface{})(interface{},error){ return AnyStruct{fmt.Sprintf(raw)} }) binder.Register(AnyStruct{},string(\"\"),func(raw interface{})(interface{},error){ strct := raw.(AnyStruct) return strct.Data }) strct :=new(AnyStruct) if err := binder.Bind(&strct,\"will set to data\"); err !=nil{ log.Println(err) } log.Println(strct.Data)// will set to data var str string if err := binder.Bind(&str, strct); err !=nil{ log.Println(err) } log.Println(str)// will set to data if err := binder.Bind(&strct,10); err !=nil{ log.Println(err)// Trying to convert 10 to struct AnyStruct } }","keywords":"documentation oscrud binder"},{"title":"Basic Exampe","type":0,"sectionRef":"#","url":"docs/example/basic-example","content":"Copy package main import( \"net/http\" \"github.com/oscrud/oscrud\" ) // Example : funcExample(ctx *oscrud.Context)*oscrud.Context { return ctx.String(http.StatusOK,\"This is an example\") } funcmain(){ server := oscrud.NewOscrud() server.RegisterEndpoint(\"GET\",\"/example\", Example) server.Start() }","keywords":"documentation oscrud example"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/getting-start","content":"If you doesn't have Go installed on your pc. You can get it here. Copy $ go get -u github.com/oscrud/oscrud After complete installation, you can Go with your beloved framework and here an hello world example. You can choose your own transport from lists, currently only supported Echo. For future will implement service discovery by default. Copy package oscrud import( \"github.com/oscrud/oscrud\" ) funcmain(){ server := oscrud.NewOscrud() server.RegisterTransport(e.NewEcho(echo.New()).UsePort(3000)) server.RegisterEndpoint(\"GET\",\"/test\",func(ctx *oscrud.Context)*oscrud.Context { return ctx.String(200,\"Hello World\").End() }) server.Start() } $ curl -v localhost:3000/test > GET /test HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.58.0 > Accept:*/* > < HTTP/1.1 200 OK < Content-Type: text/plain; charset=UTF-8 < Date: Fri, 31 Jan 2020 16:04:49 GMT < Content-Length: 11 < * Connection #0 to host localhost left intact Hello World","keywords":"documentation oscrud getting start example"},{"title":"Example","type":0,"sectionRef":"#","url":"docs/handler/example","content":"You can customize some builder to build handler, there's an example with graphql. Copy funcExample(ctx *oscrud.Context)*oscrud.Context { // Before accessing form must ParseForm() first if err := ctx.ParseForm(false); err !=nil{ return ctx.Error(400, err) } return ctx.String(200,\"Example Handler\") } funcmain(){ server := oscrud.NewOscrud() server.RegisterEndpoint(\"GET\",\"/example\", Example) }","keywords":"documentation oscrud handler"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/handler/overview","content":"oscrud.Handler is just a function func(Context) Context. oscrud.Handler act as main handler for whole framework, endpoint handler is using it and middleware options also using the same handler.","keywords":"documentation oscrud handler"},{"title":"Request Context","type":0,"sectionRef":"#","url":"docs/handler/request","content":"Method\tDescriptionMethod() string\tReturn request method, default to be smaller case get, post. Get(key string) interface{}\tGet value by key from param, query, body, header, order respectively. GetState(key string) interface{}\tGet request level state by key if not exists will fallback server state Context() context.Context\tGet request context Transport() TransportID\tGet transport name Path() string\tReturn request path Host() string\tReturn request host RequestID() string\tReturn request id State() map[string]interface{}\tReturn request state Headers() map[string]string\tReturn request headers Query() map[string]interface{}\tReturn request queries Params() map[string]string\tReturn request params Body() map[string]interface{}\tReturn request body Bind(src interface{}) error\tBind data from map specify by reflect.Tag. More information please look at Specific Binding. BindAll(src interface{}) error\tBind data from param, query, body, header, state based on json and qm tag. More information please look at All Binding. SetState(key string, value interface{})\tSet data to request level state ParseForm(mutlipart bool)\tParse Form must be called before accessing form data, may not supported in some transport. will throwing error if not supported ErrFormNotSupported. Task(func() error) *Context\tRun a function in go routine with error handling GetTransport(TransportID) (Transport, bool)\tGet a transport from core context","keywords":"documentation oscrud handler request"},{"title":"Response Context","type":0,"sectionRef":"#","url":"docs/handler/response","content":"Method\tDescriptionSet(key string, value string) Context\tAppend header to response, will override if key exists NoContent() Context\tResponse with status 204, and empty result. NotFound() Context\tResponse with status 404, and not found error. String(status int, text string) Context\tResponse with status, and raw string. Content type will be set as text/plain HTML(status int, html string) Context\tResponse with status, and html string. Content type will be set as text/html. JSON(status int, i interface{}) Context\tResponse with status, and interface. Content type will be set as application/json. XML(status int, i interface{}) Context\tResponse with status, and interface. Content type will be set as application/xml. Send(status int, contentType string, i interface{}) Context\tResponse with status, content type and interface. Transport should be handle on this if not will return error ErrResponseFailed. Error(status int, exception error)\tResponse with status, and given error Stack(status int, exception error)\tResponse with status, and given error ( stack will be provided ). errors.WithStack(). End() Context\tA signal to tell handler, the flow is reach end already. If End() didn't call until end of the handler, will return error ErrResponseNotComplete. Response() Response\tReturn response object","keywords":"documentation oscrud handler response"},{"title":"Response Object","type":0,"sectionRef":"#","url":"docs/handler/response-object","content":"Method\tDescriptionContentType() string\tReturn response content type ResponseHeaders() map[string]string\tReturn response headers Status() int\tReturn response status Exception() error\tReturn response error Result() interface{}\tReturn response result ErrorMap() map[string]interface{}\tReturn pretty error","keywords":"documentation oscrud handler response"},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/introduction","content":"","keywords":"documentation oscrud introduction"},{"title":"PR & Suggestion","type":1,"pageTitle":"Introduction","url":"docs/introduction#pr--suggestion","content":"CasesExampleSolving Issues "},{"title":"Issues","type":1,"pageTitle":"Introduction","url":"docs/introduction#issues","content":"Simple exampleWay to reproduce issuesIssues about Version "},{"title":"Event Options","type":0,"sectionRef":"#","url":"docs/options/event","content":"Event options is for applying event-driven functionality, like OnComplete. For some of the transport may have bidirectional communicate, so have to remind when every requests complete. And this function will invoke using go-routine. As order will run endpoint options and only we run server options. Copy event := oscrud.EventOptions{ OnComplete:func(ctx *oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, }","keywords":"documentation oscrud event options"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/options/overview","content":"oscrud.Options is like a middleware for customizing some specified setting, etc. Middleware, Timeout, Transport Setting, Event Setting.","keywords":"documentation oscrud options"},{"title":"Middleware Options","type":0,"sectionRef":"#","url":"docs/options/middleware","content":"Middleware options is for applying before and after lifecycle to endpoint or server. So if both server and endpoint middleware specified, will run based on : Incoming Request --> server.Before -> endpoint.Before -> Main handler -> endpoint.After -> server.After -> Outgoing Response. Copy // MiddlewareOptions : type MiddlewareOptions struct{ Before []Handler After []Handler }","keywords":"documentation oscrud middleware options"},{"title":"Timeout Options","type":0,"sectionRef":"#","url":"docs/options/timeout","content":"Timeout options is apply timeout for endpoint or server. Priority will take endpoint timeout options, if not specified will take server's timeout options. If none of them specified, will have a default 30 seconds timeout for every request. Copy timeout := oscrud.TimeoutOptions{ Duration:1* time.Microsecond, OnTimeout:func(ctx *oscrud.Context)*oscrud.Context { return ctx.Error(408, errors.New(\"Another requestimeout\")).End() }, }","keywords":"documentation oscrud timeout options"},{"title":"Transport Options","type":0,"sectionRef":"#","url":"docs/options/transport","content":"Transport Options is to limiting endpoint registration for some specified transport. Disabled transport will not receiving that route registeration. Copy disable := oscrud.TransportOptions{ DisableRegister:map[oscrud.TransportID]bool{ echo.TransportID:true, }, }","keywords":"documentation oscrud transport options"},{"title":"GraphQL Handler","type":0,"sectionRef":"#","url":"docs/package/general/graphql-handler","content":"","keywords":"documentation oscrud graphql handler third party"},{"title":"Usage","type":1,"pageTitle":"GraphQL Handler","url":"docs/package/general/graphql-handler#usage","content":"Method\tUsageHandler(schema, options...) *Handler\tDefault constructor for initialization "},{"title":"Installation","type":1,"pageTitle":"GraphQL Handler","url":"docs/package/general/graphql-handler#installation","content":"Copy $ go get github.com/oscrud/graphql-handler "},{"title":"Example","type":1,"pageTitle":"GraphQL Handler","url":"docs/package/general/graphql-handler#example","content":"Copy package main import( graphql \"github.com/graphql-go/graphql\" gh \"github.com/oscrud/graphql-handler\" ) funcmain(){ schema :=// graphql schema server := oscrud.NewServer() server.RegisterEndpoint(\"GET\",\"/graphql\", gh.Handler(schema)) server.Start() } "},{"title":"Customize Response","type":0,"sectionRef":"#","url":"docs/package/service/postgres/custom-response","content":"","keywords":"documentation oscrud service postgres"},{"title":"Example","type":1,"pageTitle":"Customize Response","url":"docs/package/service/postgres/custom-response#example","content":"Copy package main import( \"github.com/go-pg/pg\" \"github.com/go-pg/pg/orm\" \"github.com/oscrud/oscrud\" \"github.com/oscrud/postgres\" ) funcmain(){ db :=// go-pg database client model :=// oscrud service model server := oscrud.NewOscrud() pg := postgres.New() pg.UseCustomResponse(customResponse) // Service Definition server.RegisterService(\"/user\", pg.ToService(db, model),new(oscrud.ServiceOptions)) // Everything done? Start the server. server.Start() } funccustomResponse(ctx *oscrud.Context, result *postgres.ServiceResult, err error)*oscrud.Context { if err !=nil{ return ctx.Error(http.StatusBadRequest, err) } return ctx.JSON(http.StatusOK, result) } "},{"title":"Override Primary Key","type":0,"sectionRef":"#","url":"docs/package/service/postgres/override-pk","content":"","keywords":"documentation oscrud service postgres pagination"},{"title":"Example","type":1,"pageTitle":"Override Primary Key","url":"docs/package/service/postgres/override-pk#example","content":"Copy package main import( \"github.com/go-pg/pg\" \"github.com/go-pg/pg/orm\" \"github.com/oscrud/oscrud\" \"github.com/oscrud/postgres\" ) funcmain(){ db :=// go-pg database client model :=// oscrud service model server := oscrud.NewOscrud() pg := postgres.New() pg.UsePrimaryKey(\"ID\",\"id\") // Service Definition server.RegisterService(\"/user\", pg.ToService(db, model),new(oscrud.ServiceOptions)) // Everything done? Start the server. server.Start() } "},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/package/service/postgres/overview","content":"","keywords":"documentation oscrud service postgres"},{"title":"Usage","type":1,"pageTitle":"Overview","url":"docs/package/service/postgres/overview#usage","content":"Method\tUsageNew() *Postgres\tDefault constructor for initialization UseCustomResponse(ResponseBuilder) *Postgres\tCustomizing Result UsePagination(paginationType, bool) *Postgres\tSelect pagination type and is meta return with next page url by default is offset UsePrimaryKey(string, string) *Postgres\tSet primary key by default will take first primary key from model UseEncode(encodeType) *Postgres\tSelect encode type for cursor pagination to encode next cursor ToService(pg.DB, oscrud.ServiceModel) *Service\tTransform current setting into a service for registering "},{"title":"Installation","type":1,"pageTitle":"Overview","url":"docs/package/service/postgres/overview#installation","content":"Copy $ go get github.com/oscrud/postgres "},{"title":"Example","type":1,"pageTitle":"Overview","url":"docs/package/service/postgres/overview#example","content":"Copy package main import( \"github.com/go-pg/pg\" \"github.com/go-pg/pg/orm\" \"github.com/oscrud/oscrud\" \"github.com/oscrud/postgres\" ) funcmain(){ db :=// go-pg database client model :=// oscrud service model server := oscrud.NewOscrud() pg := postgres.New() pg.UsePagination(postgres.PaginationTypeCursor,true) pg.UseEncode(postgres.EncodeTypeHex) // Service Definition server.RegisterService(\"/user\", pg.ToService(db, model),new(oscrud.ServiceOptions)) // Everything done? Start the server. server.Start() } "},{"title":"custom-response","type":0,"sectionRef":"#","url":"docs/package/transport/echo/custom-response","content":"","keywords":""},{"title":"Pagination Setting","type":0,"sectionRef":"#","url":"docs/package/service/postgres/pagination","content":"","keywords":"documentation oscrud service postgres pagination"},{"title":"Example","type":1,"pageTitle":"Pagination Setting","url":"docs/package/service/postgres/pagination#example","content":"Copy package main import( \"github.com/go-pg/pg\" \"github.com/go-pg/pg/orm\" \"github.com/oscrud/oscrud\" \"github.com/oscrud/postgres\" ) funcmain(){ db :=// go-pg database client model :=// oscrud service model server := oscrud.NewOscrud() pg := postgres.New() pg.UsePagination(postgres.PaginationTypeCursor,true) pg.UseEncode(postgres.EncodeTypeHex) // Service Definition server.RegisterService(\"/user\", pg.ToService(db, model),new(oscrud.ServiceOptions)) // Everything done? Start the server. server.Start() } "},{"title":"multipart","type":0,"sectionRef":"#","url":"docs/package/transport/echo/multipart","content":"","keywords":""},{"title":"authentication","type":0,"sectionRef":"#","url":"docs/package/transport/websocket/authentication","content":"","keywords":""},{"title":"lifecycle-handler","type":0,"sectionRef":"#","url":"docs/package/transport/websocket/lifecycle-handler","content":"","keywords":""},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/package/transport/echo/overview","content":"","keywords":"documentation oscrud http echo transport"},{"title":"Usage","type":1,"pageTitle":"Overview","url":"docs/package/transport/echo/overview#usage","content":"Method\tUsageNew() *Transport\tDefault constructor for initialization UsePort(port int)\tSpecify which port to receiving requests UseMultipart(maxMemory int64)\tSpecify the max memory limit for form multipart parsing UseCustomResponse(builder ResponseBuilder)\tCustomize response "},{"title":"Installation","type":1,"pageTitle":"Overview","url":"docs/package/transport/echo/overview#installation","content":"Copy $ go get github.com/oscrud/echo "},{"title":"Example","type":1,"pageTitle":"Overview","url":"docs/package/transport/echo/overview#example","content":"Copy package main import( \"github.com/oscrud/echo\" ) funcmain(){ t := echo.New(nil) t.UsePort(3000)// specify port t.UseMultipart(5<<30) t.UseCustomResponse(func(ctx echo.Context, response oscrud.Response)error{ returnnil }) } "},{"title":"user-session","type":0,"sectionRef":"#","url":"docs/package/transport/websocket/user-session","content":"","keywords":""},{"title":"Content Type","type":0,"sectionRef":"#","url":"docs/reference/content-type","content":"List of oscrud original content-type. you can pass custom content type also but you will need to handle at transport layer so will depend on transport. Copy // ContentType Definition var( ContentTypePlainText =\"text/plain\" ContentTypeHTML =\"text/html\" ContentTypeJSON =\"application/json\" ContentTypeXML =\"application/xml\" )","keywords":"documentation oscrud reference content-type"},{"title":"Errors List","type":0,"sectionRef":"#","url":"docs/reference/error-list","content":"Error\tDescription\tMessageErrNotFound\tdefault endpoint not found error message & ctx.NotFound() error message\tendpoint or service not found ErrResponseFailed\terror message when Send()'s information, transport unable to handler or not supported\tresponse doesn't return properly in transport ErrSourceNotAddressable\terror message when binding source is not addressable\tbinder source must be addressable ErrRequestTimeout\tdefault request timeout error message\trequest timeout ErrFormNotSupported\tform is not supported for the transport\tform not supported ErrMultipartNotSupported\tmultipart form parsing is not supported for the transport\tmutlipart parsing not supported","keywords":"documentation oscrud error"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/package/transport/websocket/overview","content":"","keywords":"documentation oscrud websocket transport"},{"title":"Usage","type":1,"pageTitle":"Overview","url":"docs/package/transport/websocket/overview#usage","content":"Method\tUsageNew() *Transport\tDefault constructor for initialization UsePort(port int)\tSpecify which port to receiving requests UseUpgrader(upgrader websocket.Upgrader)\tCustomize websocket upgrader instead using default UseErrorHandler(handler ErrorHandler)\tCustomize error handler instead using default UseHandler(handler Handler)\tCustomize message handler and it's required UseAuthHandler(handler AuthHandler)\tCustomize auth handler instead using default UseCloseHandler(handler CloseHandler)\tCustomize close handler will run in goroutine GetSession(key string)\tGet session by id UpdateSession(key string, session *Session)\tUpdate session by id "},{"title":"Installation","type":1,"pageTitle":"Overview","url":"docs/package/transport/websocket/overview#installation","content":"Copy $ go get github.com/oscrud/websocket "},{"title":"Example","type":1,"pageTitle":"Overview","url":"docs/package/transport/websocket/overview#example","content":"Copy package main import( ws \"github.com/oscrud/websocket\" \"github.com/gorilla/websocket\" ) funcmain(){ t := ws.New() t.UsePort(3000)// specify port t.UseHandler( func(messageType int, message []byte, session *ws.Session){ bytes :=[]byte(\"hello world reply from server\") session.SendMessage(bytes) }, ) t.UseUpgrader( websocket.Upgrader{ CheckOrigin:func(request *http.Request)bool{ returntrue }, }, ) t.UseAuthHandler( // mainly to specify which user in the conncetion func(res http.ResponseWriter, req *http.Request)(string,*Session,error){ return uuid.New().String(),nil,nil }, ) } "},{"title":"Request Lifecycle","type":0,"sectionRef":"#","url":"docs/reference/request-lifecycle","content":"Basically a request firstly will come to Transport. Transport will do the basic handling to construct a oscrud.Request and only bring request to oscrud. Transport Usually process incoming request and construct request for pass to handler. Start Request Logger Timeout Handler Construct timeout handler & run handler using go-routine. When timeout reach will just return timeout error. Oscrud Lookup route, if exists construct middleware handler & main handler which required for the route. Before Middleware HandlerMain HandlerAfter Middleware HandlerEvent onComplete()End Request Logger","keywords":"documentation oscrud request lifecycle"},{"title":"Get Transport","type":0,"sectionRef":"#","url":"docs/server/get-transport","content":"Get transport by id from transport list Copy package oscrud funcmain(){ server := oscrud.NewOscrud() echo, exists := server.GetTransport(echo.TransportID) }","keywords":"documentation oscrud transport"},{"title":"Manually Log","type":0,"sectionRef":"#","url":"docs/server/manual-log","content":"Logging some operation with content, server context will run through loggers and call log function. Copy package oscrud funcmain(){ oscrud.Log(\"Request\",\"request started\") }","keywords":"documentation oscrud logger"},{"title":"Group Register","type":0,"sectionRef":"#","url":"docs/server/group","content":"Group is for group up a path and options, easier for those versioning or nested path. Copy package main import( \"github.com/oscrud/oscrud\" ) funcExample(ctx *oscrud.Context)*oscrud.Context { return ctx.String(200,\"Example Handler\") } funcmain(){ server := oscrud.NewOscrud() group := server.Group(\"/v1\") group.RegisterEndpoint(\"GET\",\"/example\", Example)// registered at /v1/example }","keywords":"documentation oscrud group"},{"title":"Constructing Oscrud","type":0,"sectionRef":"#","url":"docs/server/new-oscrud","content":"For constructing a new instance with some default parameters. Preferred to use this instead construct yourself unless you know what you're doing. Copy package oscrud funcmain(){ server := oscrud.NewOscrud() }","keywords":"documentation oscrud"},{"title":"Constructing Request","type":0,"sectionRef":"#","url":"docs/server/new-request","content":"Constructing new request for access endpoint. Mainly for transport to construct request when receive any incoming requests. Copy req := oscrud.NewRequest(). Transport(t). Context(e). SetBody(body). SetQuery(query). SetHeader(header). SetParam(param)","keywords":"documentation oscrud transport"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/server/overview","content":"oscrud.Server is the core struct of the framework, inside server core you can have setup method to initialize components ( middleware, binder, and more ).","keywords":"documentation oscrud"},{"title":"Register Binder","type":0,"sectionRef":"#","url":"docs/server/register-binder","content":"For register data binding method for specific struct / array / slice. Incoming data can be any type so suggested to be make a switch-case statement with default by handling other type that not supported ( usually just a string from 'header', 'query', 'body' or 'param' ). Copy package main import( \"log\" \"fmt\" \"github.com/oscrud/oscrud\" ) type AnyStruct struct{ Data string } funcmain(){ server := oscrud.NewOscrud() // register from string to AnyStruct server.RegisterBinder(string(\"\"), AnyStruct{},func(raw interface{})(interface{},error){ return AnyStruct{fmt.Sprintf(raw)} }) // register from AnyStruct to string // without this will will parse automatically with fmt.Sprintf(\"%v\", raw) server.RegisterBinder(AnyStruct{},string(\"\"),func(raw interface{})(interface{},error){ strct := raw.(AnyStruct) return strct.Data }) }","keywords":"documentation oscrud binder"},{"title":"Register Endpoint","type":0,"sectionRef":"#","url":"docs/server/register-endpoint","content":"For registering endpoint with specified method, endpoint & handler, and also able to apply endpoint level options ( mean only work on the specifed endpoint ). Copy package oscrud funcmain(){ server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx *oscrud.Context)*oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } event := oscrud.EventOptions{ OnComplete:func(ctx *oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, } // options can be apply in one line also. server.RegisterEndpoint(\"GET\",\"/test\",func(ctx *oscrud.Context)*oscrud.Context { return ctx.String(200,\"Hello World\").End() }, event, middleware) }","keywords":"documentation oscrud endpoint"},{"title":"Register Service","type":0,"sectionRef":"#","url":"docs/server/register-service","content":"For registering service on a specified path, basically service would includes 6 endpoints. It's have same registering strategy with endpoint. You can disable some of the api by passing service options. GET /basePath - Service.FindGET /basePath/:$id - Service.GetPOST /basePath - Service.CreatePUT /basePath/:$id - Service.UpdatePATCH /basePath/:$id - Service.PatchDELETE /basePath/:$id - Service.Delete Copy package oscrud funcmain(){ server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx *oscrud.Context)*oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } // Sqlike database conn initialize client := sql.MustConnect(\"mysql\", options.Connect(). SetHost(\"localhost\"). SetPort(\"3306\"). SetUsername(\"root\"). SetPassword(\"test\"), ) client.SetPrimaryKey(\"Key\") // Service Definition service := sqlike.NewService(client).Database(\"test\") // User is a query model struct based on oscrud.DataModel interface server.RegisterService(\"test\", service.ToService(\"user\",new(User)),new(oscrud.ServiceOptions), middleware) }","keywords":"documentation oscrud service"},{"title":"Register Logger","type":0,"sectionRef":"#","url":"docs/server/register-logger","content":"For register logger for the server. Every request made will be run all logger in goroutine, prevent for slowing down requests. Copy package oscrud // Logger : type Logger struct{ } // Log : func(l Logger)Log(operation string, content string){ log.Println(\"Operation - \", operation) log.Println(\"Content - \", content) } // StartRequest : func(l Logger)StartRequest(ctx *oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } // EndRequest : func(l Logger)EndRequest(ctx *oscrud.Context){ log.Println(\"**************************************\") log.Println(\"RequestID - \", ctx.RequestID()) log.Println(\"Method - \", ctx.Method()) log.Println(\"Path - \", ctx.Path()) log.Println(\"State - \", ctx.State()) log.Println(\"Header - \", ctx.Headers()) log.Println(\"Query - \", ctx.Query()) log.Println(\"Body - \", ctx.Body()) log.Println(\"**************************************\") } funcmain(){ server := oscrud.NewOscrud() server.RegisterLogger(Logger{}) }","keywords":"documentation oscrud logger"},{"title":"Register Trasnport","type":0,"sectionRef":"#","url":"docs/server/register-transport","content":"For register transport for the server, must be called before any endpoint registration. Every transport must be implemented based on interface. Copy package oscrud funcmain(){ server := oscrud.NewOscrud() server.RegisterTransport(e.NewEcho(echo.New()).UsePort(3000)) }","keywords":"documentation oscrud transport"},{"title":"Start Server","type":0,"sectionRef":"#","url":"docs/server/start","content":"For start the oscrud server, server starting will only start all the registered transport. No transported registered will panic with err. No any setup will be invoke at this step, all would be done when register, so internal call / access can be work before or even not calling Start(). Copy funcmain(){ server := oscrud.NewOscrud() server.Start() }","keywords":"documentation oscrud"},{"title":"Server State","type":0,"sectionRef":"#","url":"docs/server/state","content":"Get & Set application level state, you will have it when u have the server instance. Copy package oscrud funcmain(){ oscrud.SetState(\"state\",\"some_str\") state := oscrud.GetState(\"state\") log.Println(state)// some_str }","keywords":"documentation oscrud state custom"},{"title":"Using Options","type":0,"sectionRef":"#","url":"docs/server/use-options","content":"For apply server-level options ( mean apply to all endpoints ). Copy package oscrud funcmain(){ server := oscrud.NewOscrud() middleware := oscrud.MiddlewareOptions{ Before:[]oscrud.Handler{ func(ctx *oscrud.Context)*oscrud.Context { log.Println(\"I'm Before Middleware\") return ctx } }, } event := oscrud.EventOptions{ OnComplete:func(ctx *oscrud.Context){ log.Println(\"This running from go-routine as event-drive OnComplete().\") }, } // You can just apply all in one line. server.UseOptions(middleware, event) }","keywords":"documentation oscrud options middleware"},{"title":"Creating Own Oscrud Service","type":0,"sectionRef":"#","url":"docs/service/create-own-service","content":"For creating own service, you must have implement methods based on oscrud.Service interface. Copy type Service struct{} func(service Service)Create(ctx *oscrud.Context)*oscrud.Context { // Createing data } func(service Service)Find(ctx *oscrud.Context)*oscrud.Context { // List data } func(service Service)Get(id string, ctx *oscrud.Context)*oscrud.Context { // Get data ( should be one result always ) } func(service Service)Update(id string, ctx *oscrud.Context)*oscrud.Context { // update data } func(service Service)Patch(id string, ctx *oscrud.Context)*oscrud.Context { // patch data } func(service Service)Delete(id string, ctx *oscrud.Context)*oscrud.Context { // delete data }","keywords":"documentation oscrud service customization"},{"title":"Defining Model","type":0,"sectionRef":"#","url":"docs/service/data-model","content":"Service model is a model struct usually will be a table from database. Service model must have implmenet method from oscrud.DataModel. So when creating own service, we can use method to filter result or returning data even prevent toxic data injection. id tag will automatically assign input value from endpoint, such as GET /test/:id for a Get action. Method\tUsageToQuery(*Context, ServiceAction) (interface{}, error)\tFor returning query syntax based on service requirement, for sqlike is expr cosntruct from their query builder. ToResult(*Context, ServiceAction) (interface{}, error)\tFor construct model and return for find / get ToUpdate(*Context, ServiceModel) error\tFor construct model and return for update ToPatch(*Context, ServiceModel) error\tFor construct model and return for patch ToDelete(*Context) error\tFor construct model and return for delete ToCreate(*Context) error\tFor construct model and return for create Copy // User : type User struct{ ID int`json:\"id\" oscrud:\"id\"` Name string`json:\"name\"` } // ToCreate : func(user *User)ToCreate(ctx *oscrud.Context)error{ iflen(user.Name)>20{ return errors.New(\"username have a maximum length 20\") } returnnil } // ToResult : func(user *User)ToResult(ctx *oscrud.Context, action oscrud.ServiceAction)(interface{},error){ return user,nil } // ToQuery : func(user *User)ToQuery(ctx *oscrud.Context, action oscrud.ServiceAction)(interface{},error){ return user,nil } // ToPatch : func(user *User)ToPatch(ctx *oscrud.Context, incoming oscrud.ServiceModel)error{ incomingUser := incoming.(*User) user.Name = incomingUser.Name returnnil } // ToUpdate : func(user *User)ToUpdate(ctx *oscrud.Context, incoming oscrud.ServiceModel)error{ incomingUser := incoming.(*User) user.Name = incomingUser.Name returnnil } // ToDelete : func(user *User)ToDelete(ctx *oscrud.Context)error{ returnnil }","keywords":"documentation oscrud service model"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/service/overview","content":"Service has 6 action following CRUD standard. Basically service will registering 6 endpoints by default. Currently creating a service may required some basic knowledge on reflect package, we trying to minimize usage of reflect when creating own service. GET /basePath - Service.FindPOST /basePath - Service.CreateGET /basePath/:id - Service.GetPUT /basePath/:id - Service.UpdatePATCH /basePath/:id - Service.PatchDELETE /basePath/:id - Service.Delete","keywords":"documentation oscrud service"},{"title":"Overview","type":0,"sectionRef":"#","url":"docs/transport/overview","content":"Transport act as communicate tools between client and server. Transport would have own name to determine request is from which transport.","keywords":"documentation oscrud transport"},{"title":"Creating Own Oscrud Transport","type":0,"sectionRef":"#","url":"docs/transport/create-own-transport","content":"For creating own transport, you have to implement method from oscrud.Transport. Basically have 2 type registraion way. Way 1 is in Register for those transport which support endpoint routing like Echo. Way 2 is in Start for those transport doesn't have a router support like net/http package. Copy type Transport struct{} const( TransportName oscrud.TransportID =\"TransportName\" ) func(t *Transport)Name() oscrud.TransportID { return TransportName } func(t *Transport)Register(method string, endpoint string, handler oscrud.TransportHandler){ // Every endpoint registration will call this method. } func(t *Transport)Start()error{ // Transport start receiving request }","keywords":"documentation oscrud transport customization"}]